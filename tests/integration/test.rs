# [derive (serde :: Serialize , Debug , postgres_types :: FromSql , Clone , PartialEq)] # [postgres (name = "domain_composite")] pub struct DomainComposite { # [postgres (name = "txt")] pub txt : String , # [postgres (name = "json")] pub json : serde_json :: Value , # [postgres (name = "nb")] pub nb : i32 , # [postgres (name = "arr")] pub arr : Vec < serde_json :: Value > , } # [derive (Debug)] pub struct DomainCompositeBorrowed < 'a > { pub txt : & 'a str , pub json : postgres_types :: Json < & 'a serde_json :: value :: RawValue > , pub nb : i32 , pub arr : crate :: ArrayIterator < 'a , postgres_types :: Json < & 'a serde_json :: value :: RawValue > > , } impl < 'a > From < DomainCompositeBorrowed < 'a >> for DomainComposite { fn from (DomainCompositeBorrowed { txt , json , nb , arr , } : DomainCompositeBorrowed < 'a > ,) -> Self { Self { txt : txt . into () , json : serde_json :: from_str (json . 0 . get ()) . unwrap () , nb : nb , arr : arr . map (| v | serde_json :: from_str (v . 0 . get ()) . unwrap ()) . collect () , } } } impl < 'a > postgres_types :: FromSql < 'a > for DomainCompositeBorrowed < 'a > { fn from_sql (ty : & postgres_types :: Type , out : & 'a [u8]) -> Result < DomainCompositeBorrowed < 'a > , Box < dyn std :: error :: Error + Sync + Send >> { let fields = match * ty . kind () { postgres_types :: Kind :: Composite (ref fields) => fields , _ => unreachable ! () , } ; let mut out = out ; let num_fields = postgres_types :: private :: read_be_i32 (& mut out) ? ; if num_fields as usize != fields . len () { return std :: result :: Result :: Err (std :: convert :: Into :: into (format ! ("invalid field count: {} vs {}" , num_fields , fields . len ()))) ; } let _oid = postgres_types :: private :: read_be_i32 (& mut out) ? ; let txt = postgres_types :: private :: read_value (fields [0] . type_ () , & mut out) ? ; let _oid = postgres_types :: private :: read_be_i32 (& mut out) ? ; let json = postgres_types :: private :: read_value (fields [1] . type_ () , & mut out) ? ; let _oid = postgres_types :: private :: read_be_i32 (& mut out) ? ; let nb = postgres_types :: private :: read_value (fields [2] . type_ () , & mut out) ? ; let _oid = postgres_types :: private :: read_be_i32 (& mut out) ? ; let arr = postgres_types :: private :: read_value (fields [3] . type_ () , & mut out) ? ; Ok (DomainCompositeBorrowed { txt , json , nb , arr , }) } fn accepts (ty : & postgres_types :: Type) -> bool { ty . name () == "domain_composite" && ty . schema () == "public" } } # [derive (Debug)] pub struct DomainComposite Params < 'a > { pub txt : & 'a str , pub json : & 'a serde_json :: value :: Value , pub nb : i32 , pub arr : & 'a [& 'a serde_json :: value :: Value] , } impl < 'a > postgres_types :: ToSql for DomainCompositeParams < 'a > { fn to_sql (& self , ty : & postgres_types :: Type , out : & mut postgres_types :: private :: BytesMut ,) -> Result < postgres_types :: IsNull , Box < dyn std :: error :: Error + Sync + Send >> { let DomainCompositeParams { txt , json , nb , arr , } = self ; let fields = match * ty . kind () { postgres_types :: Kind :: Composite (ref fields) => fields , _ => unreachable ! () , } ; out . extend_from_slice (& (fields . len () as i32) . to_be_bytes ()) ; for field in fields { out . extend_from_slice (& field . type_ () . oid () . to_be_bytes ()) ; let base = out . len () ; out . extend_from_slice (& [0 ; 4]) ; let r = match field . name () { "txt" => postgres_types :: ToSql :: to_sql (& crate :: Domain (txt) , field . type_ () , out) , "json" => postgres_types :: ToSql :: to_sql (& crate :: Domain (json) , field . type_ () , out) , "nb" => postgres_types :: ToSql :: to_sql (& crate :: Domain (nb) , field . type_ () , out) , "arr" => postgres_types :: ToSql :: to_sql (& crate :: Domain (& crate :: DomainArray (arr)) , field . type_ () , out) , _ => unreachable ! () } ; let count = match r ? { postgres_types :: IsNull :: Yes => - 1 , postgres_types :: IsNull :: No => { let len = out . len () - base - 4 ; if len > i32 :: MAX as usize { return Err (Into :: into ("value too large to transmit")) ; } len as i32 } } ; out [base .. base + 4] . copy_from_slice (& count . to_be_bytes ()) ; } Ok (postgres_types :: IsNull :: No) } fn accepts (ty : & postgres_types :: Type) -> bool { if ty . name () != "domain_composite" { return false ; } match * ty . kind () { postgres_types :: Kind :: Composite (ref fields) => { if fields . len () != 4 { return false ; } fields . iter () . all (| f | match f . name () { "txt" => < crate :: Domain :: < & 'a str > as postgres_types :: ToSql > :: accepts (f . type_ ()) , "json" => < crate :: Domain :: < & 'a serde_json :: value :: Value > as postgres_types :: ToSql > :: accepts (f . type_ ()) , "nb" => < crate :: Domain :: < i32 > as postgres_types :: ToSql > :: accepts (f . type_ ()) , "arr" => < crate :: Domain :: < crate :: DomainArray :: < & 'a serde_json :: value :: Value , & [& 'a serde_json :: value :: Value] > > as postgres_types :: ToSql > :: accepts (f . type_ ()) , _ => false , }) } _ => false , } } fn to_sql_checked (& self , ty : & postgres_types :: Type , out : & mut postgres_types :: private :: BytesMut ,) -> Result < postgres_types :: IsNull , Box < dyn std :: error :: Error + Sync + Send >> { postgres_types :: __to_sql_checked (self , ty , out) } }
